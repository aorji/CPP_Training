/*

В первом уроке вы реализовали простой шаблон ValueHolder, в этом задании мы используем его чтобы написать класс Any (интересно, что не шаблонный), который позволяет хранить значения любого типа! Например, вы сможете  создать массив объектов типа Any, и сохранять в них int-ы, double-ы или даже объекты Array. Подробности в шаблоне кода. 

Hint: в нешаблонном классе Any могут быть шаблонные методы, например, шаблонный конструктор.

Для реализации вам может потребоваться оператор dynamic_cast.

С++ предоставляет и более простой способ узнать конкретный класс по указателю (или ссылке) на базовый класс. Для этого можно использовать оператор dynamic_cast. Например, если у вас есть указатель Expression *, и вы хотите узнать, указывает ли этот указатель на самом деле на объект Number, то сделать это можно так:

Expression *expression = parse(code);
Number *number = dynamic_cast<Number *>(expression);
if (number)
    std::cout << "It's a number" << std::endl;
else
    std::cout << "It is not a number" << std::endl;
Если expression действительно указывает на объект Number (или на один из его наследников, но в нашем примере их нет), то оператор dynamic_cast<Number *> вернет правильный указатель. Если expression указывает не на класс Number, то будет возвращен нулевой указатель. Т. е. если в переменной number хранится нулевой указатель, значит expression не указывает на Number на самом деле.

Для правильной работы оператора dynamic_cast в нашем примере требуется, чтобы класс Expression был полиморфным, т. е. в нем должна быть как минимум одна виртуальная функция (например, деструктор). Стандарт определяет работу dynamic_cast и с не полиморфными типами, но в этом случае никаких проверок типа времени исполнения выполняться не будет - часто, это не то, что требуется.

Если передать оператору dynamic_cast нулевой указатель, то он просто вернет нулевой указатель нужного типа, поэтому проверять указатель перед передачей в dynamic_cast не нужно.



*/


Профиль
Решения
Stepik logo
Каталог
Мои курсы
Создать


Поиск…
Русский

Анастасия
Шаблоны функций – Шаг 11
Урок от: 
Александр Смаль
9 / 9
Решения 
	
 верно (3 балла)	5 дней назад
 
Анастасия Оджи (решение #78663198) 
25 ноября 2018 г., 01:49
// Эти классы реализовывать заново не нужно
struct ICloneable;

// Поле data_ типа T в классе ValueHolder
// открыто, к нему можно обращаться
template <typename T>
struct ValueHolder;

// Это класс, который вам нужно реализовать
class Any
{
    public:
    // В классе Any должен быть конструктор,
    // который можно вызвать без параметров,
    // чтобы работал следующий код:
    //    Any empty; // empty ничего не хранит
    Any( void ): data_(0){}
    // В классе Any должен быть шаблонный
    // конструктор от одного параметра, чтобы
    // можно было создавать объекты типа Any,
    // например, следующим образом:
    //    Any i(10); // i хранит значение 10
    template <typename Other>
    Any( Other const & data){
        data_ = new ValueHolder<Other>(data);
    }
    // Не забудьте про десdataтруктор. Все выделенные
    // ресурсы нужно освободить.
    ~Any(){ delete data_; }
    // В классе Any также должен быть конструктор
    // копирования (вам поможет метод clone
    // интерфейса ICloneable)
    Any( Any const & any){
        if (any.data_)
            data_ = any.data_->clone();
        else
            data_ = 0;
    }
    // В классе должен быть оператор присваивания и/или
    // шаблонный оператор присваивания, чтобы работал
    // следующий код:
    //    Any copy(i); // copy хранит 10, как и i
    //    empty = copy; // empty хранит 10, как и copy
    //    empty = 0; // а теперь empty хранит 0
    Any &operator=(Any const & any) {
        if (this != &any){
            this->~Any();
                data_ = any.data_->clone();
        }
        return *this; 
    }
    template <typename Other>
    Any &operator=(Other const & any) {
        this->~Any();
            data_ = new ValueHolder<Other>(any);
        return *this; 
    }
    // Ну и template <typename T>наконец, мы хотим уметь получать хранимое
    // значение, для этого определите в классе Any
    // шаблонный метод cast, который возвращает
    // указатель на хранимое значение, или нулевой
    // указатель в случае несоответствия типов или
    // если объект Any ничего не хранит:
    //    int *iptr = i.cast<int>(); // *iptr == 10
    //    char *cptr = i.cast<char>(); // cptr == 0,
    //        // потому что i хранит int, а не char
    //    Any empty2;
    //    int *p = empty2.cast<int>(); // p == 0
    // При реализации используйте оператор dynamic_cast.
    //
    // Допустим у вас есть два наследника класса Base: Derived1 
    // и Derived2. Кроме того у вас есть указать baseptr
    // типа Base*. Как проверить указывает ли этот указатель на
    // самом деле на объект класса Derived1 или на объект 
    // класса Derived2? Для этого можно воспользоваться dynamic_cast-ом:
    //
    // Derived1 *derived1ptr = dynamic_cast<Derived1*>(baseptr);
    //
    // Если derived1ptr не равен 0, то  baseptr на самом деле
    // указывал на объект класса Derived1, если же derivedptr равен 0,
    // то baseptr на самом деле указывал на объкт какого-то другого 
    // класса (например, Derived2). Это можно проверить так:
    //
    // Derived2 *derived2ptr = dynamic_cast<Derived2*>(baseptr);
    //
    // dynamic_cast работает только, если в классе есть хотя бы
    // один виртуальный метод, и в шаблоне ValueHolder такой
    // как раз имеется.
    template <typename Other>
    Other * cast(){
        if (data_) {
            ValueHolder<Other> *res = dynamic_cast<ValueHolder<Other> *>(data_);
            if (res) {
                return &(res->data_);
            }
        }
        return 0;
        
    }
    private:
    ICloneable *data_;
};
