#include <iostream>
// #include "private_to_public.hpp"
/*
Определен следующий класс (он также приведен в комментарии в шаблоне кода):

struct Cls {
    Cls(char c, double d, int i);
private:
    char c;
    double d;
    int i;
};
Как видно, все поля этого класса закрытые, ваша задача реализовать несколько функций, которые дают полный доступ к этим полям (см. шаблон кода), несмотря на то, что они закрытые.

Внимание: предполагаемое решение этого задания существенно опирается на Undefined Behaviour и является исключительно учебным, но полезно для лучшего понимания того, как работают модификаторы доступа. Решение было проверено на различных компиляторах (g++/clang++/icc/msvc), но мы настоятельно не рекомендуем использовать подобные трюки в боевом коде.

Требования к реализации: при решении этого задания вам разрешается заводить любые вспомогательные функции и классы, но не изменять определение класса Cls. Не нужно вводить или выводить что-либо, также не нужно определять функцию main.
*/


// Класс Cls определен точно таким образом:
 
 struct Cls {
 Cls(char c, double d, int i): c(c), d(d), i(i){};
 private:
     char c;
     double d;
     int i;
 };
 
 
 struct ClsPub {
 ClsPub(char c, double d, int i): c(c), d(d), i(i){};
 public:
     char c;
     double d;
     int i;
 };

// Эта функция должна предоставить доступ к полю c объекта cls.
// Обратите внимание, что возвращается ссылка на char, т. е.
// доступ предоставляется на чтение и запись.
char &get_c(Cls &cls) {
    void *ptr = static_cast<void *>(&cls);
    ClsPub *publ = static_cast<ClsPub *>(ptr);
    return publ->c;
}

// Эта функция должна предоставить доступ к полю d объекта cls.
// Обратите внимание, что возвращается ссылка на double, т. е.
// доступ предоставляется на чтение и запись.
double &get_d(Cls &cls) {
    void *ptr = static_cast<void *>(&cls);
    ClsPub *publ = static_cast<ClsPub *>(ptr);
    return publ->d;
}

// Эта функция должна предоставить доступ к полю i объекта cls.
// Обратите внимание, что возвращается ссылка на int, т. е.
// доступ предоставляется на чтение и запись.
int &get_i(Cls &cls) {
    void *ptr = static_cast<void *>(&cls);
    ClsPub *publ = static_cast<ClsPub *>(ptr);
    return publ->i;
}

int main(){
	Cls c('a', 1.1, 2);
	std::cout << get_c(c);
}